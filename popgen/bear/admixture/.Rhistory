setwd("~/github_repos/snowtracks/metagenomics")
# === Read CSV ===
df <- read.csv("deep_stats.csv", stringsAsFactors = FALSE)
# Remove % signs and convert to numeric
df_long <- df %>%
pivot_longer(-Name, names_to = "Category", values_to = "Percent") %>%
mutate(Percent = as.numeric(sub("%", "", Percent)))
# Set a consistent order of categories
df_long$Category <- factor(df_long$Category, levels = c(
"Chordate_reads","Artificial_reads","Unclassified_reads","Microbial_reads",
"Bacterial_reads","Viral_reads","Fungal_reads","Protozoan_reads"
))
# Color palette
cols <- c(
"Chordate_reads" = "#1b9e77",
"Artificial_reads" = "#d95f02",
"Unclassified_reads" = "#7570b3",
"Microbial_reads" = "#e7298a",
"Bacterial_reads" = "#66a61e",
"Viral_reads" = "#e6ab02",
"Fungal_reads" = "#a6761d",
"Protozoan_reads" = "#666666"
)
# Helper to make a single donut chart
make_donut <- function(df_subset, show_legend = FALSE){
ggplot(df_subset, aes(x = 2, y = Percent, fill = Category)) +
geom_bar(stat = "identity", width = 1, color = NA) +
coord_polar(theta = "y") +
xlim(0.5, 2.5) +
coord_cartesian(ylim = c(0, 100), clip = "off") +
theme_void() +
theme(
legend.position = if (show_legend) "center" else "none",
legend.justification = "center"
) +
scale_fill_manual(values = cols) +
ggtitle(unique(df_subset$Name))
}
# === Create plots ===
plots <- df_long %>%
split(.$Name) %>%
map(~ make_donut(.x, show_legend = FALSE))
# === Blank placeholder (true empty donut cell) ===
blank_plot <- ggplot() +
coord_polar(theta = "y") +
xlim(0.5, 2.5) +
coord_cartesian(ylim = c(0, 100)) +
theme_void()
# === Legend-only plot (drawn in blank slot) ===
legend_plot <- make_donut(
df_long %>% filter(Name == unique(Name)[1]),
show_legend = TRUE
) +
theme(plot.title = element_blank())
# === Explicit layout: 5 per row, legend in slot 5 ===
final_plot <-
wrap_plots(
plots[[1]], plots[[2]], plots[[3]], plots[[4]], legend_plot,
plots[[5]], plots[[6]], plots[[7]], plots[[8]], plots[[9]],
ncol = 5
)
# === Print figure ===
final_plot
# === Load libraries ===
library(tidyverse)
library(patchwork)
setwd("~/github_repos/snowtracks/metagenomics")
# === Read CSV ===
df <- read.csv("deep_stats.csv", stringsAsFactors = FALSE)  # replace with your actual CSV path
# Remove % signs and convert to numeric
df_long <- df %>%
pivot_longer(-Name, names_to = "Category", values_to = "Percent") %>%
mutate(Percent = as.numeric(sub("%","",Percent)))
# Set a consistent order of categories
df_long$Category <- factor(df_long$Category, levels = c(
"Chordate_reads","Artificial_reads","Unclassified_reads","Microbial_reads",
"Bacterial_reads","Viral_reads","Fungal_reads","Protozoan_reads"))
# Color palette
cols <- c(
"Chordate_reads" = "#1b9e77",
"Artificial_reads" = "#d95f02",
"Unclassified_reads" = "#7570b3",
"Microbial_reads" = "#e7298a",
"Bacterial_reads" = "#66a61e",
"Viral_reads" = "#e6ab02",
"Fungal_reads" = "#a6761d",
"Protozoan_reads" = "#666666"
)
# Helper to make a single donut chart
make_donut <- function(df_subset, show_legend=FALSE){
ggplot(df_subset, aes(x=2, y=Percent, fill=Category)) +
geom_bar(stat="identity", width=1, color=NA) +  # no gaps between bars
coord_polar(theta="y") +
xlim(0.5, 2.5) +       # creates the ring (donut)
ylim(0, 100) +         # force all pies to same scale
theme_void() +
theme(legend.position = if(show_legend) "right" else "none") +
scale_fill_manual(values=cols) +
ggtitle(unique(df_subset$Name))
}
# === Split data for plotting ===
plots <- df_long %>%
split(.$Name) %>%
imap(~ make_donut(.x, show_legend = .y == "CX113F"))  # legend in chosen plot
# === Layout: 4 on first row, 5 on second row, same size pies ===
final_plot <- wrap_plots(plots[1:4], nrow=1) / wrap_plots(plots[5:9], nrow=1) +
plot_layout(guides="collect")  # collect legend to avoid resizing
# === Print figure ===
final_plot
# === Load libraries ===
library(tidyverse)
library(patchwork)
setwd("~/github_repos/snowtracks/metagenomics")
# === Read CSV ===
df <- read.csv("deep_stats.csv", stringsAsFactors = FALSE)
# Remove % signs, convert to numeric, NORMALISE to 100
df_long <- df %>%
pivot_longer(-Name, names_to = "Category", values_to = "Percent") %>%
mutate(Percent = as.numeric(sub("%","",Percent))) %>%
group_by(Name) %>%
mutate(Percent = Percent / sum(Percent) * 100) %>%
ungroup()
# Set a consistent order of categories
df_long$Category <- factor(df_long$Category, levels = c(
"Chordate_reads","Artificial_reads","Unclassified_reads","Microbial_reads",
"Bacterial_reads","Viral_reads","Fungal_reads","Protozoan_reads"))
# Color palette
cols <- c(
"Chordate_reads" = "#1b9e77",
"Artificial_reads" = "#d95f02",
"Unclassified_reads" = "#7570b3",
"Microbial_reads" = "#e7298a",
"Bacterial_reads" = "#66a61e",
"Viral_reads" = "#e6ab02",
"Fungal_reads" = "#a6761d",
"Protozoan_reads" = "#666666"
)
# Helper to make a single donut chart
make_donut <- function(df_subset, show_legend = FALSE){
ggplot(df_subset, aes(x = 2, y = Percent, fill = Category)) +
geom_col(width = 1, color = NA) +     # solid fills, no borders
coord_polar(theta = "y") +
xlim(0.5, 2.5) +
scale_y_continuous(expand = c(0, 0)) + # CRITICAL: removes gaps
theme_void() +
theme(legend.position = if(show_legend) "right" else "none") +
scale_fill_manual(values = cols) +
ggtitle(unique(df_subset$Name))
}
# === Split data for plotting ===
plots <- df_long %>%
split(.$Name) %>%
imap(~ make_donut(.x, show_legend = .y == "CX113F"))
# === Layout with extra vertical spacing ===
final_plot <-
wrap_plots(plots[1:4], nrow = 1) /
plot_spacer() /
wrap_plots(plots[5:9], nrow = 1) +
plot_layout(
heights = c(1, 0.25, 1),   # controls gap size
guides = "collect"
)
# === Print figure ===
final_plot
ggsave(
filename = "donut_plots.png",
plot = final_plot,
width = 14,
height = 7,
units = "in",
dpi = 300,
bg = "white"
)
ggsave(
filename = "donut_plots.png",
plot = final_plot,
width = 14,
height = 6,
units = "in",
dpi = 300,
bg = "white"
)
# === Load required libraries ===
library(tidyverse)
library(shadowtext)
setwd("~/github_repos/snowtracks/popgen/bear/pca")
# === File paths ===
evec_file <- "bear_proj.evec"
eigval_file <- "bear_proj.eigenvalues"
pop_file  <- "populations.csv"
# === Control label size ===
label_text_size <- 3  # adjust as needed
# === Read eigenvectors (.evec) ===
evec <- read_table2(
evec_file,
comment = "#",
col_names = FALSE
)
evec <- evec[-1,]
num_pcs <- ncol(evec) - 2
pc_names <- paste0("PC", 1:num_pcs)
colnames(evec) <- c("sample", pc_names, "sample_dup")
evec <- evec %>% select(-sample_dup)
# === Read eigenvalues (.eigenvalues) ===
eigvals <- read_table2(eigval_file, col_names = FALSE) %>% pull(X1)
var_explained <- eigvals / sum(eigvals) * 100
# === Read population info ===
pop <- read_csv(pop_file, col_names = FALSE, trim_ws = TRUE)
colnames(pop)[1:2] <- c("sample", "population")
# === Merge data ===
merged <- left_join(evec, pop, by = "sample")
# === Define highlighted samples, colors, and legend labels ===
highlight_colors <- c(
CX1138    = "#E41A1C",  # red
CX113E = "#377EB8",  # blue
CX113C = "#4DAF4A",  # green
CX115H   = "#984EA3"   # purple
)
highlight_labels <- c(
CX1138    = "CX1138 - Slovenia, 0.66x",
CX113E = "CX113E - Slovenia, 0.14x",
CX113C = "CX113C - Slovenia, 0.11x",
CX115H   = "CX115H - Slovenia, 0.01x"
)
highlight_samples <- names(highlight_colors)
merged <- merged %>%
mutate(
highlight = sample %in% highlight_samples,
highlight_color = if_else(highlight, highlight_colors[sample], NA_character_)
)
# === Define which populations to label ===
pop_to_label <- c("Italy", "Slovenia", "Sweden", "USA", "Alaska", "Canada", "Far East")
# === Filter population centroids for labeling ===
pop_labels <- merged %>%
group_by(population) %>%
summarise(
across(starts_with("PC"), ~mean(.x, na.rm = TRUE)),
.groups = "drop"
) %>%
mutate(label = population) %>%
filter(population %in% pop_to_label)
# === Common theme ===
base_theme <- theme_minimal(base_size = 14) +
theme(
legend.position = "right",
panel.grid.minor = element_blank()
)
# === Helper function for PCA plotting with labels ===
plot_pca <- function(merged, var_explained, pc_x, pc_y, file_name, highlight_colors, highlight_labels) {
p <- ggplot() +
# Regular samples
geom_point(
data = merged %>% filter(!highlight),
aes(x = .data[[pc_x]], y = .data[[pc_y]], color = population),
size = 3
) +
# Highlighted samples
geom_point(
data = merged %>% filter(highlight),
aes(x = .data[[pc_x]], y = .data[[pc_y]], fill = sample),
shape = 24, color = "black", size = 4, stroke = 1.2
) +
# Population legend with 2 columns
scale_color_discrete(
name = "Population",
guide = guide_legend(ncol = 2)
) +
# Highlighted samples legend stays single column
scale_fill_manual(
name = "Highlighted samples",
values = highlight_colors,
labels = highlight_labels,
guide = guide_legend(override.aes = list(shape = 24, size = 5, color = "black"))
) +
# Population labels at centroids
geom_shadowtext(
data = pop_labels,
aes(x = .data[[pc_x]], y = .data[[pc_y]], label = label, colour = population),
bg.colour = "black",
bg.r = 0.15,
fontface = "bold",
size = label_text_size,
hjust = -0.1,
show.legend = FALSE
) +
# Axis labels
labs(
x = paste0(pc_x, " (", round(var_explained[as.numeric(sub("PC", "", pc_x))], 1), "%)"),
y = paste0(pc_y, " (", round(var_explained[as.numeric(sub("PC", "", pc_y))], 1), "%)")
) +
base_theme
show(p)
ggsave(file_name, plot = p, width = 11, height = 5, dpi = 300)
}
# === List of PC pairs to plot ===
pc_pairs <- list(
c("PC1", "PC2"),
c("PC2", "PC3"),
c("PC1", "PC4"),
c("PC1", "PC5")
)
# === Loop through PC pairs and plot ===
for (pair in pc_pairs) {
pc_x <- pair[1]
pc_y <- pair[2]
file_name <- paste0("bear_pca_", pc_x, "_", pc_y, ".png")
plot_pca(merged, var_explained, pc_x, pc_y, file_name, highlight_colors, highlight_labels)
}
# === Load required libraries ===
library(tidyverse)
library(shadowtext)
setwd("~/github_repos/snowtracks/popgen/bear/pca")
# === File paths ===
evec_file <- "bear_proj.evec"
eigval_file <- "bear_proj.eigenvalues"
pop_file  <- "populations.csv"
# === Control label size ===
label_text_size <- 3  # adjust as needed
# === Read eigenvectors (.evec) ===
evec <- read_table2(
evec_file,
comment = "#",
col_names = FALSE
)
evec <- evec[-1,]
num_pcs <- ncol(evec) - 2
pc_names <- paste0("PC", 1:num_pcs)
colnames(evec) <- c("sample", pc_names, "sample_dup")
evec <- evec %>% select(-sample_dup)
# === Read eigenvalues (.eigenvalues) ===
eigvals <- read_table2(eigval_file, col_names = FALSE) %>% pull(X1)
var_explained <- eigvals / sum(eigvals) * 100
# === Read population info ===
pop <- read_csv(pop_file, col_names = FALSE, trim_ws = TRUE)
colnames(pop)[1:2] <- c("sample", "population")
# === Merge data ===
merged <- left_join(evec, pop, by = "sample")
# === Define highlighted samples, colors, and legend labels ===
highlight_colors <- c(
CX1138    = "#E41A1C",  # red
CX113E = "#377EB8",  # blue
CX113C = "#4DAF4A",  # green
CX115H   = "#984EA3"   # purple
)
highlight_labels <- c(
CX1138    = "CX1138 - Slovenia, 0.66x",
CX113E = "CX113E - Slovenia, 0.14x",
CX113C = "CX113C - Slovenia, 0.11x",
CX115H   = "CX115H - Slovenia, 0.01x"
)
highlight_samples <- names(highlight_colors)
merged <- merged %>%
mutate(
highlight = sample %in% highlight_samples,
highlight_color = if_else(highlight, highlight_colors[sample], NA_character_)
)
# === Define which populations to label ===
pop_to_label <- c("Italy", "Slovenia", "Sweden", "USA", "Alaska", "Canada", "Far East")
# === Filter population centroids for labeling ===
pop_labels <- merged %>%
group_by(population) %>%
summarise(
across(starts_with("PC"), ~mean(.x, na.rm = TRUE)),
.groups = "drop"
) %>%
mutate(label = population) %>%
filter(population %in% pop_to_label)
# === Common theme ===
base_theme <- theme_minimal(base_size = 14) +
theme(
legend.position = "right",
panel.grid.minor = element_blank()
)
# === Helper function for PCA plotting with labels ===
plot_pca <- function(merged, var_explained, pc_x, pc_y, file_name, highlight_colors, highlight_labels) {
p <- ggplot() +
# Regular samples
geom_point(
data = merged %>% filter(!highlight),
aes(x = .data[[pc_x]], y = .data[[pc_y]], color = population),
size = 3
) +
# Highlighted samples
geom_point(
data = merged %>% filter(highlight),
aes(x = .data[[pc_x]], y = .data[[pc_y]], fill = sample),
shape = 24, color = "black", size = 4, stroke = 1.2
) +
# Population legend with 2 columns
scale_color_discrete(
name = "Population",
guide = guide_legend(ncol = 2)
) +
# Highlighted samples legend stays single column
scale_fill_manual(
name = "Highlighted samples",
values = highlight_colors,
labels = highlight_labels,
guide = guide_legend(override.aes = list(shape = 24, size = 5, color = "black"))
) +
# Population labels at centroids
geom_shadowtext(
data = pop_labels,
aes(x = .data[[pc_x]], y = .data[[pc_y]], label = label, colour = population),
bg.colour = "black",
bg.r = 0.15,
fontface = "bold",
size = label_text_size,
hjust = -0.1,
show.legend = FALSE
) +
# Axis labels
labs(
x = paste0(pc_x, " (", round(var_explained[as.numeric(sub("PC", "", pc_x))], 1), "%)"),
y = paste0(pc_y, " (", round(var_explained[as.numeric(sub("PC", "", pc_y))], 1), "%)")
) +
base_theme
show(p)
ggsave(file_name, plot = p, width = 11, height = 5, dpi = 300)
}
# === List of PC pairs to plot ===
pc_pairs <- list(
c("PC1", "PC2"),
c("PC2", "PC3"),
c("PC2", "PC4"),
c("PC1", "PC4"),
c("PC1", "PC5")
)
# === Loop through PC pairs and plot ===
for (pair in pc_pairs) {
pc_x <- pair[1]
pc_y <- pair[2]
file_name <- paste0("bear_pca_", pc_x, "_", pc_y, ".png")
plot_pca(merged, var_explained, pc_x, pc_y, file_name, highlight_colors, highlight_labels)
}
setwd("~/github_repos/snowtracks/popgen/bear/admixture")
library(tidyverse)
# === Load static data ===
fam  <- read.table("bears.fam", header = FALSE)
pops <- read.csv("populations.csv", header = FALSE)
# --- Extract sample names in ADMIXTURE order ---
samples <- fam$V2
# --- Build population lookup table ---
pop_df <- pops %>%
transmute(
sample = V1,      # sample name
population = V2   # population label
)
# --- Population order for plotting ---
# --- Population order for plotting (from file) ---
pop_order <- readLines("pop_order.txt")
# === Helper function for plotting ADMIXTURE results ===
plot_admixture <- function(K) {
# --- Load Q file ---
Q <- read.table(paste0("bears.", K, ".Q"), header = FALSE)
# --- Combine Q + metadata safely ---
tbl <- Q %>%
mutate(sample = samples) %>%
left_join(pop_df, by = "sample")
n_clusters <- ncol(Q)
# --- Prepare data for plotting ---
plot_data <- tbl %>%
tidyr::pivot_longer(
cols = starts_with("V"),
names_to = "cluster",
values_to = "prob"
) %>%
group_by(sample) %>%
mutate(
likely_assignment = cluster[which.max(prob)],
assignment_prob   = max(prob)
) %>%
ungroup() %>%
arrange(
factor(population, levels = pop_order),
desc(assignment_prob)
) %>%
mutate(
sample          = factor(sample, levels = unique(sample)),
cluster         = factor(cluster, levels = paste0("V", 1:n_clusters)),
population_plot = factor(population, levels = pop_order)
)
# --- Plot ---
p <- ggplot(plot_data, aes(x = sample, y = prob, fill = cluster)) +
geom_col(width = 1) +
facet_grid(~population_plot, scales = "free_x", space = "free_x") +
theme_minimal() +
theme(
axis.text.x   = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 7),
axis.ticks.x  = element_blank(),
panel.spacing = unit(0.2, "lines"),
strip.text    = element_text(size = 9, angle = 70),
legend.position = "none",
plot.margin   = margin(10, 10, 10, 10),
strip.clip    = "off"
) +
labs(
x = "",
y = "Ancestry proportion",
title = paste("K =", K)
)
print(p)
# --- Save plot ---
ggsave(
filename = paste0("bear_plot_K", K, ".png"),
plot = p,
width = 12, height = 5, units = "in", dpi = 300
)
}
# === Run for selected K values ===
Ks <- c(2, 3, 4, 5, 10)
purrr::walk(Ks, plot_admixture)
